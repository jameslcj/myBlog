---
title: 面向对象的程序设计
date: 2017-06-29 10:25:08
tags: javaScript高级程序设计笔记
---
## 理解对象
> Object.defineProperty(操作对象, 操作属性, 属性类型) IE8及以下不要使用
Object.defineProperties(操作对象, {}) 同事可以定义多个属性  支持IE9+
Object.getOwnPropertyDescriptor(操作对象, 属性)

### 属性类型
- [[configurable]]: 是否可以配置, 能够通过delete删除属性, 修改其属性特性(可以理解为修改属性名), 默认true
- [[enumerable]]: 表示能否通过for-in遍历, 默认true
- [[writable]]: 表示能否修改属性的值
- [[value]]: 属性的数据值, 默认undefined

```
var obj = {}
Object.defineProperty(obj, "name", {
  writable: false,
  value: "hello"
});
console.log(obj)//Object {name: "hello"}
obj.name = 'world'
console.log(obj)//Object {name: "hello"}
// 一下就配置了writable和value, 没有配置configurable和enumerable 那么这两个值默认为false了
delete obj.name //false
```

### 访问器属性
#### getter setter
- [[configurable]]: 是否可以配置, 能够通过delete删除属性, 修改其属性特性(可以理解为修改属性名), 默认true
- [[enumerable]]: 表示能否通过for-in遍历, 默认true
- [[get]]: 在读取属性时调用的函数, 默认undefined
- [[set]]: 在写入属性时调用的函数, 默认undefined
```
var obj = {_age: 20}
//get和set方法 忽略其中一个方法, 说明那方法设置为false
Object.defineProperty(obj, "age", {
    get: function() {
        return this._age;
    },
    set: function(newVal) {
        if (newVal > 18) {
            this._age = 18;
        } else {
            this._age = newVal;
        }
    }
});
obj.age = 55 //18
obj.age = 16 //16
```

## 创建对象
### 创建对象的几种方式
```
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.getName = function() {
    return this.name;
  }
}
var p1 = new Person('p1', 18);
//--
var obj = new Object();
Person.call(obj, 'p2', 18);
obj.getName() //'p2'
```
### 为什么要用原型的方式实例化
>原型继承可以共享属性和方法

```
//普通的
function Person(name, age) {
  this.name = name;
  this.age = age;
  //这种方式等价于 new Function("return this.name;"); 当实例多个对象时, 此方法也被实例了多次, 不公用一个方法
  this.getName = function() {
    return this.name;
  }
}

//原型链的
function Person(name, age) {
  this.name = name;
  this.age = age;
}
//如果使用原型链继承的方式, 就可以共用同一个方法
Person.prototype.getName = function() {
  return this.name;
}
```

### 获取原型的方法
> 构造方法.prototype === Object.getPrototypeOf(实例对象)

```
function Person() {
}
Person.prototype.getName = function() {
  return this.name;
}

ver person = new Person;

Object.getPrototypeOf(person) === Person.prototype //true
//判断是否是某一对象的原型
Person.prototype.isPrototypeOf(person) //true
```

### 修改原型上的属性值
```
function Person() {
}
Person.prototype.name = 'hello'
var person = new Person();

//默认使用原型上的值
person.name; //hello
person.hasOwnProperty('name');//false
//覆盖原型上的值
person.name = 'world';
person.name;// world
person.hasOwnProperty('name');//true
//删除自定义的值
delete person.name; //true
//重新指向原型上的值
person.name; //hello
person.hasOwnProperty('name');//false
```

### Object.getOwnPropertyNames() 与 Object.keys()的区别
> Object.keys()只能获取可以枚举的key
Object.getOwnPropertyNames() 可以获取所有key(不包括原型链上的key)

### 使用对象字面量原型继承
>使用这种方式会将constructor的指向改变为Object, 因为原型直接被一个对象覆盖

```
Test.prototype = {
    name: 'zhichen'
}

test.constructor == Test //false
test.constructor == Object//true

test instanceof Test //true
test instanceof Object //true
```
>为了避免这种问题, 我们需要手动改变constructor指向, 但是这样会使这个key的枚举性变为true(默认是false)

```
Test.prototype = {
    constructor: Test,
    name: 'zhichen'
}
test.constructor == Test //true
test.constructor == Object//false

test instanceof Test //true
test instanceof Object //true

Object.keys(Test.prototype)// ["constructor", "name"]
```

>所以正确的姿势如下

```
Test.prototype = {
    name: 'zhichen'
}
Object.defineProperty(Test.prototype, "constructor", {
    enumerable: false,
    value: Test
});
Object.keys(Test.prototype)//["name"]
```

### 原型的动态
>由于每个对象当没有找对对应的key时都会去原型链上查找, 所以当我们动态改变原型上的属性, 会有可能直接影响到对象, 即使先实例对象
对象和原型之间的关系, 是用指针链接的, 而不是副本形式

```
Test.prototype = {
    constructor: Test,
    name: 'zhichen'
}
var test = new Test()
test.sayHi(); //ERROR
Test.prototype.sayHi = function(){
    console.log("hello wolrd");
}
test.sayHi()//hello world
```

>使用字面量对象赋值, 会改变构造函数原型指针指向, 重新指向新原型对象, 但是之前实例化的对象还是指向原来的原型对象, 所以无法获取新原型对象的属性

```
function Test(){}
var test = new Test()
Test.prototype = {
    constructor: Test,
    name: 'zhichen',
	  sayHi: function() {
		    console.log("hello world");
    }
}
test.sayHi()//ERROR
```
