---
title: 事件
date: 2017-08-09 10:12:50
tags: javaScript高级程序设计笔记
---
## 事件流
### DOM事件流
> DOM2级事件规定事件流包括三个阶段: 事件捕获阶段, 处于目标阶段和事件冒泡阶段. IE9+的等浏览器都支持此事件流

## 事件处理程序
### DOM0级事件处理程序

```
var div = document.getElementById("div1");
div.onclick = function() {
	console.log(this.id);//div1
}

div.onclick = null;//删除事件
```

### DOM2级事件处理程序
- addEventListener(要处理的事件名, 作为事件处理的函数, 是否捕捉);
- removeEventListener(要处理的事件名, 作为事件处理的函数, 是否捕捉);

```
var div = document.getElementById("div1"); 
var handler = function() {
	//do something
}
div.addEventListener('click', handler, false);
div.removeEventListener('click', handler, false);
```

### IE事件处理程序
- attachEvent(事件处理名称, 事件处理函数)
- detachEvent(事件处理名称, 事件处理函数)

> `attachEvent`绑定的事件需要添加前缀`on`, 而`addEventListener`不需要; 事件处理函数的`this`指向`window`

```
var div = document.getElementById("div1"); 
var handler = function() {
	console.log(this === window); //true
}
div.attachEvent('onclick', handler);
div.detachEvent('onclick', handler);
```
## 事件对象
### DOM中的事件

> 只有在事件处理程序执行期间, event对象才会存在, 一旦事件处理程序执行完成, event对象就会被销毁

> 当我们将事件挂载在body上, 并点击body中的一个按钮btn, 会有如下结果;

```
document.body.onclick = function(event) {
	console.log(event.currentTarget === document.body);//true
	console.log(this === document.body);//true
	console.log(event.target === document.getElementById("btn"));//true
}
```

- preventDefault() 阻止默认事件
- stopPropagation() 阻止事件的捕捉和冒泡
- eventPhase 值为 1 是捕捉阶段, 值为2是处于目标对象上, 值为3是冒泡阶段

### IE中的事件对象

```
var btn = document.getElemntById('btn');
btn.onclick = function() {
	window.event.type; //click
	window.event.returnValue = false;//阻止默认事件
	window.event.cancelBubble = true;//阻止冒泡事件
	window.event.scrElemnt == this;//true 事件对象
}

## 事件类型
### UI事件
- DOMActivate: 表示元素已被用户操作(通过鼠标或键盘)激活. 这个事件被在dom3级事件废弃, 建议不使用
- load: 当页面完全加载后在window上面触发, 当所有框架都加载完毕时在框架集上面触发, 当图像加载完毕时在<img>元素上面触发, 或者嵌入的内容加载完毕时在`<object>`元素上面触发
- unload: 当页面卸载时在window上面触发等, 与load事件对应
- abort: 用户停止下载过程时, 如果嵌入的内容没有加载完毕时, 则在`<object>`元素上面触发
- error: 当发生JavaScript错误时在window上触发, 当无法加载图像时在`<img>`元素上面触发等
- select: 用户选择文本框中的字符时触发
- resize: 窗口大小变化时触发
- scroll: 滚动条滚动时触发

### 焦点事件
- focus: 当元素获取焦点时触发, 这个事件不冒泡
- focusin: 在元素获取焦点时触发, 这个事件冒泡
- blur: 当元素失去焦点时触发, 这个事件不冒泡
- focusout: 在元素失去焦点时触发, 是html事件blur的通用版本

> 当焦点从一个元素移动到另一个元素时, 会依次触发下列事件, 其中focusout blur DOMFocusOut在失去焦点元素上触发, 其他在获取焦点元素上触发

- focusout 
- focusin
- blur
- DOMFocusOut
- focus
- DOMFocusIn

### 鼠标事件
- click
- dbclick
- mousedown
- mouseenter
- mouseleave
- mousemove
- mouseout
- mouseover
- mouseup

> 除了 mouseenterh, mouseleave 不冒泡, 其他都冒泡; 事件间也会有关联; 只有在同一个元素上相继触发mousedown和mouseup才会触发click事件, 取消任何一个事件都不会触发click

1. 客户区坐标位置
- clientX 鼠标在客户区的水平坐标
- clientY 鼠标在客户区的垂直坐标

2. 页面坐标位置
- pageX 
- pageY

> 此两值与clientX, clientY类似, 只不过从页面本身而不是从视口的左边和定边开始计算的

```
pageX = event.clietX + (docuemnt.body.scrollLeft || document.documentElement.scrollLeft);
pageY = event.clietY + (docuemnt.body.scrollTop || document.documentElement.scrollTop);
```

3. 屏幕坐标位置
- screenX 到屏幕最左侧的坐标
- screenY 到屏幕最上方的坐标

4. 相关元素
 
> 在嵌套的元素里绑定`mouseover`, `mouseout`等事件, 会触发多余事件, 我们可以通过判断相关元素, 来避免多余事件触发, IE9+可以使用`event.relatedTarget`属性判断, ie8及以下使用`event.fromElment`和`event.toElement`属性判断 

```
var EventUtil = {
	getRelatedTarget: function(event) {
		if (event.relatedTarget) {
			return event.relatedTarget;
		} else if (event.toElement) {
			return event.toElement;
		} else if (event.fromElement) {
			return event.fromElement;
		} else {
			return null;
		}
	}
}
```

5. 鼠标按钮

> 当发生`mousedown`或`mouseup`事件时, 可以根据`event.button`来判断按下的是鼠标的哪个键; firefox支持一个`DOMMourseScroll`事件, 会冒泡到`window`上

6. 鼠标滚轮事件

> 滚轮事件`mousewheel`都会冒泡到`document`或`window`上

```
$(document).on("mousewheel", function(e) {console.log(e.detail)})
//firefox
$(window).on("DOMMouseScroll", function(e) {console.log("detail:", e.detail)})
```

### 键盘与文本事件
- keydown 任意键都会触发
- keypress 只要字符才会触发
- keyup 当用户释放按键时才触发

- 获取字符编码

```
var eventUtil = {
	getCharCode: function(event) {
		if (typeof event.charCode == "number") {
			return event.charCode;
		} else {
			return event.keyCode;
		}
	}
}
```

- getModifierState("Shift/Control/AltGraph/Meta") 检测是否被按下
- textInput事件

> 只会在可编辑区域触发事件, 与keypress也有区别, keypress在按下影响文本显示时也会触发(比如退格键)

- event.inputmethod 表示把文本输入到文本框中的方式, 比如黏贴复制, 拖放, 手写等

### 复合事件
> 可以让用户输入键盘上没有的字符

- compositionstart
- compositionupdate
- compositionend

```
//判断是否支持复合事件
document.implementation.hasFeature("CompositionEvent", "3.0")
```

### 变动事件
- DOMSubtreeModified DOM结构发生任何变化时触发
- DOMNodeInserted
- DOMNodeRemoved
- DOMNodeInsertedIntoDocument 在DOMNodeInserted后触发
- DOMNodeRemovedFromDocument 在DOMNodeRemoved后触发
- DOMAttrModified 
- DOMCharacterDataModified 值变化触发

### HTML5事件
1. contextmenu 鼠标右击调出上下文事件, 通常可以用来替换右击显示样式

```
var div = document.getElementById("div");
div.oncontextmenu = function(e) {
	e.preventDefault();
	//阻止默认显示, 显示自定样式
	var menu = document.getElementById("menu");
	menu.style.left = e.clientX + 'px';
	menu.style.top = e.clientY + 'px';
	menu.style.visibility = 'visible';
}
``` 

2. beforeunload 关闭页面前提示是否关闭
3. DOMContentLoaded 

> 这个方法与load的事件的区别是: load会等待js, 图片加载完毕, 而这个事件发生在形成完整的DOM树后触发;
对于IE9以前的浏览器不支持此事件, 通过setTimeout(function() {}, 0)实现, 并且作为页面中第一个超时顶用.

4. readystatechange事件
- uninitialized(未初始化) 对象未初始化 
- loading(正在加载) 对象正在加载数据
- loaded 对象加载数据完毕
- interactive (交互) 可以操作对象了, 但还没有完全加载 (DOMContentLoaded事件也几乎同时发送在此时)
- complete(完成) 对象已经加载完成

> 不是没有对象的加载, 都会有以上阶段, 有些对象会跳过某些阶段

```
document.onreadystatechange = function(event) {
	if (document.readyState == 'interactive' || document.readyState == 'complete') {
		consolelog('content loaded')
	}
}
```

5. pageshow和pagehide
- pageshow 页面显示时触发, 不管是否来自缓存, 会在load事件后触发; 可以通过event.persisted来判断, true为来自缓存
- pagehide 在页面卸载时触发, 在unload事件前触发

```
window.onpageshow = function(e) {console.log(e.persisted)}
```

6. hashchange事件
```
window.onhashchange = function(event) {
	console.log(event.oldURL, event.newURL)
}
```

