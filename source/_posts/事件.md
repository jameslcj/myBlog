---
title: 事件
date: 2017-08-09 10:12:50
tags: javaScript高级程序设计笔记
---
## 事件流
### DOM事件流
> DOM2级事件规定事件流包括三个阶段: 事件捕获阶段, 处于目标阶段和事件冒泡阶段. IE9+的等浏览器都支持此事件流

## 事件处理程序
### DOM0级事件处理程序

```
var div = document.getElementById("div1");
div.onclick = function() {
	console.log(this.id);//div1
}

div.onclick = null;//删除事件
```

### DOM2级事件处理程序
- addEventListener(要处理的事件名, 作为事件处理的函数, 是否捕捉);
- removeEventListener(要处理的事件名, 作为事件处理的函数, 是否捕捉);

```
var div = document.getElementById("div1"); 
var handler = function() {
	//do something
}
div.addEventListener('click', handler, false);
div.removeEventListener('click', handler, false);
```

### IE事件处理程序
- attachEvent(事件处理名称, 事件处理函数)
- detachEvent(事件处理名称, 事件处理函数)

> `attachEvent`绑定的事件需要添加前缀`on`, 而`addEventListener`不需要; 事件处理函数的`this`指向`window`

```
var div = document.getElementById("div1"); 
var handler = function() {
	console.log(this === window); //true
}
div.attachEvent('onclick', handler);
div.detachEvent('onclick', handler);
```
## 事件对象
### DOM中的事件

> 只有在事件处理程序执行期间, event对象才会存在, 一旦事件处理程序执行完成, event对象就会被销毁

> 当我们将事件挂载在body上, 并点击body中的一个按钮btn, 会有如下结果;

```
document.body.onclick = function(event) {
	console.log(event.currentTarget === document.body);//true
	console.log(this === document.body);//true
	console.log(event.target === document.getElementById("btn"));//true
}
```

- preventDefault() 阻止默认事件
- stopPropagation() 阻止事件的捕捉和冒泡
- eventPhase 值为 1 是捕捉阶段, 值为2是处于目标对象上, 值为3是冒泡阶段

### IE中的事件对象

```
var btn = document.getElemntById('btn');
btn.onclick = function() {
	window.event.type; //click
	window.event.returnValue = false;//阻止默认事件
	window.event.cancelBubble = true;//阻止冒泡事件
	window.event.scrElemnt == this;//true 事件对象
}

## 事件类型
### UI事件
- DOMActivate: 表示元素已被用户操作(通过鼠标或键盘)激活. 这个事件被在dom3级事件废弃, 建议不使用
- load: 当页面完全加载后在window上面触发, 当所有框架都加载完毕时在框架集上面触发, 当图像加载完毕时在<img>元素上面触发, 或者嵌入的内容加载完毕时在`<object>`元素上面触发
- unload: 当页面卸载时在window上面触发等, 与load事件对应
- abort: 用户停止下载过程时, 如果嵌入的内容没有加载完毕时, 则在`<object>`元素上面触发
- error: 当发生JavaScript错误时在window上触发, 当无法加载图像时在`<img>`元素上面触发等
- select: 用户选择文本框中的字符时触发
- resize: 窗口大小变化时触发
- scroll: 滚动条滚动时触发

### 焦点事件
- focus: 当元素获取焦点时触发, 这个事件不冒泡
- focusin: 在元素获取焦点时触发, 这个事件冒泡
- blur: 当元素失去焦点时触发, 这个事件不冒泡
- focusout: 在元素失去焦点时触发, 是html事件blur的通用版本

> 当焦点从一个元素移动到另一个元素时, 会依次触发下列事件, 其中focusout blur DOMFocusOut在失去焦点元素上触发, 其他在获取焦点元素上触发

- focusout 
- focusin
- blur
- DOMFocusOut
- focus
- DOMFocusIn

### 鼠标事件
- click
- dbclick
- mousedown
- mouseenter
- mouseleave
- mousemove
- mouseout
- mouseover
- mouseup

> 除了 mouseenterh, mouseleave 不冒泡, 其他都冒泡; 事件间也会有关联; 只有在同一个元素上相继触发mousedown和mouseup才会触发click事件, 取消任何一个事件都不会触发click

1. 客户区坐标位置
- clientX 鼠标在客户区的水平坐标
- clientY 鼠标在客户区的垂直坐标

2. 页面坐标位置
- pageX 
- pageY

> 此两值与clientX, clientY类似, 只不过从页面本身而不是从视口的左边和定边开始计算的

```
pageX = event.clietX + (docuemnt.body.scrollLeft || document.documentElement.scrollLeft);
pageY = event.clietY + (docuemnt.body.scrollTop || document.documentElement.scrollTop);
```

3. 屏幕坐标位置
- screenX 到屏幕最左侧的坐标
- screenY 到屏幕最上方的坐标

4. 相关元素
 
> 在嵌套的元素里绑定`mouseover`, `mouseout`等事件, 会触发多余事件, 我们可以通过判断相关元素, 来避免多余事件触发, IE9+可以使用`event.relatedTarget`属性判断, ie8及以下使用`event.fromElment`和`event.toElement`属性判断 

```
var EventUtil = {
	getRelatedTarget: function(event) {
		if (event.relatedTarget) {
			return event.relatedTarget;
		} else if (event.toElement) {
			return event.toElement;
		} else if (event.fromElement) {
			return event.fromElement;
		} else {
			return null;
		}
	}
}
```

5. 鼠标按钮

> 当发生`mousedown`或`mouseup`事件时, 可以根据`event.button`来判断按下的是鼠标的哪个键; firefox支持一个`DOMMourseScroll`事件, 会冒泡到`window`上

6. 鼠标滚轮事件

> 滚轮事件`mousewheel`都会冒泡到`document`或`window`上

```
$(document).on("mousewheel", function(e) {console.log(e.detail)})
//firefox
$(window).on("DOMMouseScroll", function(e) {console.log("detail:", e.detail)})
```
