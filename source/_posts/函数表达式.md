---
title: 函数表达式
date: 2017-07-06 09:26:11
tags: javaScript高级程序设计笔记
---
## 函数
```
function funcName(arg0, arg1, arg2){}
console.log(funcName.name)//funcName(函数的名字)
console.log(funcName.length)//3(参数个数)
```
### 函数声明与函数表达式的区别
>函数表达式必须先赋值才有对应的值, 而函数声明可以在函数名前调用

```
console.log(func)//function func(){}
//函数表达式
function func(){}

console.log(fn)//undefined
//函数表达式
var fn = function(){}
```

## 递归
> 在递归时, 可以用arguments.callee代替自身函数名, 这样就可以解耦, 随意修改函数名

```
function factorial(num) {
  if (num <= 1) {
    return 1;
  }
  return num * arguments.callee(num-1);
}
```

## 闭包
> 闭包会携带包含它的函数作用域, 所以它所占的内存逼其他函数多, 建议尽量少用; V8引擎会尝试回收被闭包占用的内存;
个人理解: 任何函数其实都是闭包

### 闭包与变量
> 本来有一个需求是, 调用`createFunctions()[1]()`函数就返回对应的索引的值, 也就是1, 但是结果却是10; 因为这个函数返回的是一个闭包;
这个闭包又要返回i, 但在它自身的作用域里无法找到这个变量, 它就会去作用域链上查找, 但是作用域链上的i, 最循环结束后, 已变成10了; 所以调用任何一个闭包,
都是指向同一个作用域链上的i, 其值为10;

```
function createFunctions() {
    var result = [];

    for (var i=0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }

    return result;
}
createFunctions()[1]()//10
```

> 可以修改为如下, 将i通过函数的方式传递进去, 那么num就是i的副本, 它的改变不所i而改变;
因此当调用`createFunctions()[1]()`时, 需要返回num, 再其自身作用域里没有num, 就往上一级作用域里查找,
正好可以找到num, 并返回, 其值也是和外层循环时传递进来的值一样;

```
function createFunctions() {
    var result = [];

    for (var i=0; i < 10; i++) {
        result[i] = (function(num) {
          return function() {
              return num;
          }
        })(i)
    }

    return result;
}
createFunctions()[1]()//1
```

### 内存泄露
> 在ie9以前的浏览器dom节点是使用计数引用的方式管理回收内存, 因此不合理利用闭包会导致内存泄露;
下面这个函数onclick的闭包函数, 引用了elemnt.id, 所以导致element无法被回收

```
function assignHandler() {
    var element = document.getElementById("someElement");
    element.onclick = function() {
        alert(element.id)
    };
}
```
> 可以将代码改成如下, 避免泄露, 首先建立一个element.id的副本, 再最后将element设置为null

```
function assignHandler() {
    var element = document.getElementById("someElement");
    var id = element.id;
    element.onclick = function() {
        alert(id)
    };
    element = null;
}
```

### 关于this
```
var name = "the window"
var object  = {
    name: "my object",
    getName: function() {
        return this.name;
    }
};
object.getName();//"my object"
(object.getName)();//"my object"
(object.getName = object.getName)();//"the window"
```
