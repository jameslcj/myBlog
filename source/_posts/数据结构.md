---
title: 数据结构与算法
date: 2018-05-09 08:39:49
tags: 数据结构与算法
---
## 二叉树
### 递归方法
```c
#include <stdio.h>

typedef struct {
    int data;
    struct BiTNode* lChild, *rChild;
}BiTNode, *BiTree;

void printData(int num) {
    printf(" %d ", num);
}

void inOrder(BiTNode* T) {
    if (T == NULL) {
        return;
    }
    inOrder(T->lChild);
    printData(T->data);
    inOrder(T->rChild);
}

BiTNode* copyTree(BiTNode* T) {
    if (T == NULL) {
        return NULL;
    }
    BiTNode* newNode = NULL;
    BiTNode* newLChild = NULL;
    BiTNode* newRChild = NULL;
    
    if (T->lChild != NULL) {
        newLChild = copyTree(T->lChild);
    }
    
    if (T->rChild != NULL) {
        newRChild = copyTree(T->rChild);
    }
    
    newNode = (BiTNode*)malloc(sizeof(BiTNode));
    memset(newNode, 0, sizeof(BiTNode));
    if (newNode == NULL) {
        return NULL;
    }
    newNode->data = T->data;
    newNode->lChild = newLChild;
    newNode->rChild = newRChild;
    
    
    return newNode;
}

int main(int argc, const char * argv[]) {
    
    BiTNode t1, t2, t3, t4, t5;
    memset(&t1, 0, sizeof(BiTNode));
    memset(&t2, 0, sizeof(BiTNode));
    memset(&t3, 0, sizeof(BiTNode));
    memset(&t4, 0, sizeof(BiTNode));
    memset(&t5, 0, sizeof(BiTNode));
    t1.data = 1;
    t1.lChild = &t2;
    t1.rChild = &t3;
    t2.data = 2;
    t2.lChild = &t4;
    t3.data = 3;
    t3.rChild = &t5;
    t4.data = 4;
    t5.data = 5;
    
    printf("\nold tree: \n");
    inOrder(&t1);
    
    printf("\nnew tree: \n");
    BiTNode* newT = NULL;
    newT = copyTree(&t1);
    inOrder(newT);
    
    return 0;
}
```

### 非递归方法
```cpp
#include <stack>
struct BiTNode{
    int data;
    struct BiTNode* lChild, *rChild;
};

void printData(int num) {
    printf(" %d ", num);
}

void inOrder(BiTNode* T) {
    if (T == NULL) {
        return;
    }
    inOrder(T->lChild);
    printData(T->data);
    inOrder(T->rChild);
}


BiTNode* goLeft(BiTNode* T,stack<BiTNode*> &s) {
    if (T == NULL) {
        return NULL;
    }
    
    //判断是否有左节点, 如果有就入栈, 否则就返回当前节点
    while (T->lChild != NULL) {
        s.push(T);
        T = T->lChild;
    }
    return T;
}

void inOrder2(BiTNode* T) {
    if (T == NULL) {
        return;
    }
    
    stack<BiTNode*> s;
    
    //步骤1
    T = goLeft(T, s);
    
    while (T) {
        printData(T->data);
        if (T->rChild) {
            //如果有右子树 就重复步骤1
            T = goLeft(T->rChild, s);
        } else if (!s.empty()) {
            //如果没右子树并且栈顶不为空, 则取出栈顶, 回退到栈顶元素
            T = s.top();
            s.pop();
        } else {
            T = NULL;
        }
    }
}


int main(int argc, const char * argv[]) {
    
    BiTNode t1, t2, t3, t4, t5;
    memset(&t1, 0, sizeof(BiTNode));
    memset(&t2, 0, sizeof(BiTNode));
    memset(&t3, 0, sizeof(BiTNode));
    memset(&t4, 0, sizeof(BiTNode));
    memset(&t5, 0, sizeof(BiTNode));
    t1.data = 1;
    t1.lChild = &t2;
    t1.rChild = &t3;
    t2.data = 2;
    t2.lChild = &t4;
    t3.data = 3;
    t3.rChild = &t5;
    t4.data = 4;
    t5.data = 5;
    
    printf("\n递归方法: \n");
    inOrder(&t1);
    
    printf("\n非递归方法: \n");
    inOrder2(&t1);

    return 0;
}

```

### Morris方法遍历二叉树

1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

    a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

    b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。


[步骤](https://img-blog.csdn.net/20150829152118062)

```c
void inorderMorrisTraversal(BiTNode *root) {
    BiTNode* curr = NULL, *prev = NULL;
    
    while (curr != NULL) {
        if (curr->lChild == NULL) {
            //1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
            printData(curr->data);
            curr = curr->rChild;
        } else {
            prev = curr->lChild;
            while (prev->rChild != NULL && prev->rChild != curr) {
                prev = curr->rChild;
            }
            
            if (prev->rChild == NULL) {
                //a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。
                prev->rChild = curr;
                curr = curr->lChild;
            } else {
                //b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。
                printData(curr->data);
                curr = curr->rChild;
                prev->rChild = NULL;
            }
        }
    }
    
}
```

[参考](https://www.cnblogs.com/BaroC/p/5188545.html)

### 插入排序
```cpp
void printArr(int* arr, int len) {
    printf("开始打印: ");
    for (int i = 0; i < len; i ++) {
        printf(" %d ", arr[i]);
    }
}
void selectOrder(int *arr, int len) {
    
    for (int i = 1; i < len; i++) {
        int tmp = arr[i];
        int k = i;
        
        for (int j = i - 1; (j >= 0) && (arr[j] > tmp); j--) {
            arr[j + 1] = arr[j];
            k = j;
        }
        
        arr[k] = tmp;
    }
}

int main(int argc, const char * argv[]) {
    int arr[] = {2,1,32,12,42,5};
    int len = sizeof(arr) / sizeof(int);
    selectOrder(arr, len);
    printArr(arr, len);
    
    return 0;
}

```