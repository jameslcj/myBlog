---
title: 数据结构
date: 2018-05-09 08:39:49
tags: 数据结构与算法
---
## 二叉树
### 递归方法
```c
#include <stdio.h>

typedef struct {
    int data;
    struct BiTNode* lChild, *rChild;
}BiTNode, *BiTree;

void printData(int num) {
    printf(" %d ", num);
}

void inOrder(BiTNode* T) {
    if (T == NULL) {
        return;
    }
    inOrder(T->lChild);
    printData(T->data);
    inOrder(T->rChild);
}

BiTNode* copyTree(BiTNode* T) {
    if (T == NULL) {
        return NULL;
    }
    BiTNode* newNode = NULL;
    BiTNode* newLChild = NULL;
    BiTNode* newRChild = NULL;
    
    if (T->lChild != NULL) {
        newLChild = copyTree(T->lChild);
    }
    
    if (T->rChild != NULL) {
        newRChild = copyTree(T->rChild);
    }
    
    newNode = (BiTNode*)malloc(sizeof(BiTNode));
    memset(newNode, 0, sizeof(BiTNode));
    if (newNode == NULL) {
        return NULL;
    }
    newNode->data = T->data;
    newNode->lChild = newLChild;
    newNode->rChild = newRChild;
    
    
    return newNode;
}

int main(int argc, const char * argv[]) {
    
    BiTNode t1, t2, t3, t4, t5;
    memset(&t1, 0, sizeof(BiTNode));
    memset(&t2, 0, sizeof(BiTNode));
    memset(&t3, 0, sizeof(BiTNode));
    memset(&t4, 0, sizeof(BiTNode));
    memset(&t5, 0, sizeof(BiTNode));
    t1.data = 1;
    t1.lChild = &t2;
    t1.rChild = &t3;
    t2.data = 2;
    t2.lChild = &t4;
    t3.data = 3;
    t3.rChild = &t5;
    t4.data = 4;
    t5.data = 5;
    
    printf("\nold tree: \n");
    inOrder(&t1);
    
    printf("\nnew tree: \n");
    BiTNode* newT = NULL;
    newT = copyTree(&t1);
    inOrder(newT);
    
    return 0;
}
```

### 非递归方法
```cpp
#include <stack>
struct BiTNode{
    int data;
    struct BiTNode* lChild, *rChild;
};

void printData(int num) {
    printf(" %d ", num);
}

void inOrder(BiTNode* T) {
    if (T == NULL) {
        return;
    }
    inOrder(T->lChild);
    printData(T->data);
    inOrder(T->rChild);
}


BiTNode* goLeft(BiTNode* T,stack<BiTNode*> &s) {
    if (T == NULL) {
        return NULL;
    }
    
    //判断是否有左节点, 如果有就入栈, 否则就返回当前节点
    while (T->lChild != NULL) {
        s.push(T);
        T = T->lChild;
    }
    return T;
}

void inOrder2(BiTNode* T) {
    if (T == NULL) {
        return;
    }
    
    stack<BiTNode*> s;
    
    //步骤1
    T = goLeft(T, s);
    
    while (T) {
        printData(T->data);
        if (T->rChild) {
            //如果有右子树 就重复步骤1
            T = goLeft(T->rChild, s);
        } else if (!s.empty()) {
            //如果没右子树并且栈顶不为空, 则取出栈顶, 回退到栈顶元素
            T = s.top();
            s.pop();
        } else {
            T = NULL;
        }
    }
}


int main(int argc, const char * argv[]) {
    
    BiTNode t1, t2, t3, t4, t5;
    memset(&t1, 0, sizeof(BiTNode));
    memset(&t2, 0, sizeof(BiTNode));
    memset(&t3, 0, sizeof(BiTNode));
    memset(&t4, 0, sizeof(BiTNode));
    memset(&t5, 0, sizeof(BiTNode));
    t1.data = 1;
    t1.lChild = &t2;
    t1.rChild = &t3;
    t2.data = 2;
    t2.lChild = &t4;
    t3.data = 3;
    t3.rChild = &t5;
    t4.data = 4;
    t5.data = 5;
    
    printf("\n递归方法: \n");
    inOrder(&t1);
    
    printf("\n非递归方法: \n");
    inOrder2(&t1);

    return 0;
}

```